"""
Grammar Playground - Parser Generator
Generates recursive descent and table-driven parsers
"""

from typing import List, Dict, Set, Optional
from .grammar import Grammar, Symbol, Production, EPSILON, END_MARKER
from .ll1_analyzer import LL1Analyzer, LL1Table


class RecursiveDescentGenerator:
    """Generates a recursive descent parser from an LL(1) grammar"""
    
    def __init__(self, grammar: Grammar, analyzer: LL1Analyzer):
        self.grammar = grammar
        self.analyzer = analyzer
        if not analyzer.ll1_table:
            analyzer.analyze()
    
    def generate(self, language: str = "python") -> str:
        """Generate parser code in the specified language"""
        if language.lower() == "python":
            return self._generate_python()
        elif language.lower() == "javascript":
            return self._generate_javascript()
        else:
            raise ValueError(f"Unsupported language: {language}")
    
    def _generate_python(self) -> str:
        """Generate Python recursive descent parser"""
        lines = [
            '"""',
            'Recursive Descent Parser',
            'Generated by Grammar Playground',
            '"""',
            '',
            'from typing import List, Optional, Any',
            '',
            '',
            'class ParseError(Exception):',
            '    """Raised when parsing fails"""',
            '    pass',
            '',
            '',
            'class Token:',
            '    """Represents a token from the lexer"""',
            '    def __init__(self, type: str, value: str, pos: int = 0):',
            '        self.type = type',
            '        self.value = value',
            '        self.pos = pos',
            '    ',
            '    def __repr__(self):',
            '        return f"Token({self.type}, {self.value!r})"',
            '',
            '',
            'class ParseTreeNode:',
            '    """Node in the parse tree"""',
            '    def __init__(self, symbol: str, children: List["ParseTreeNode"] = None, token: Token = None):',
            '        self.symbol = symbol',
            '        self.children = children or []',
            '        self.token = token',
            '    ',
            '    def is_terminal(self) -> bool:',
            '        return self.token is not None',
            '    ',
            '    def __repr__(self):',
            '        if self.is_terminal():',
            '            return f"Leaf({self.symbol}: {self.token.value!r})"',
            '        return f"Node({self.symbol}, {len(self.children)} children)"',
            '',
            '',
            'class Parser:',
            '    """Recursive Descent Parser"""',
            '    ',
            '    def __init__(self, tokens: List[Token]):',
            '        self.tokens = tokens',
            '        self.pos = 0',
            '        self.current_token: Optional[Token] = tokens[0] if tokens else None',
            '    ',
            '    def error(self, expected: str) -> None:',
            '        token = self.current_token',
            '        if token:',
            '            raise ParseError(f"Expected {expected} but got {token.type} at position {token.pos}")',
            '        else:',
            '            raise ParseError(f"Expected {expected} but reached end of input")',
            '    ',
            '    def advance(self) -> Token:',
            '        """Move to the next token"""',
            '        token = self.current_token',
            '        self.pos += 1',
            '        if self.pos < len(self.tokens):',
            '            self.current_token = self.tokens[self.pos]',
            '        else:',
            '            self.current_token = None',
            '        return token',
            '    ',
            '    def match(self, expected_type: str) -> Token:',
            '        """Match and consume a token of the expected type"""',
            '        if self.current_token and self.current_token.type == expected_type:',
            '            return self.advance()',
            '        self.error(expected_type)',
            '    ',
            '    def lookahead(self) -> Optional[str]:',
            '        """Return the type of the current token"""',
            '        if self.current_token:',
            '            return self.current_token.type',
            '        return "$"  # End marker',
            '    ',
            '    def parse(self) -> ParseTreeNode:',
            f'        """Parse the input starting from {self.grammar.start_symbol}"""',
            f'        tree = self.parse_{self._safe_name(str(self.grammar.start_symbol))}()',
            '        if self.current_token is not None:',
            '            self.error("end of input")',
            '        return tree',
            '',
        ]
        
        # Generate a parsing method for each non-terminal
        for nt in sorted(self.grammar.non_terminals, key=lambda x: str(x)):
            lines.extend(self._generate_nt_method_python(nt))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _generate_nt_method_python(self, nt: Symbol) -> List[str]:
        """Generate the parsing method for a non-terminal"""
        safe_name = self._safe_name(str(nt))
        productions = self.grammar.get_productions_for(nt)
        
        lines = [
            f'    def parse_{safe_name}(self) -> ParseTreeNode:',
            f'        """Parse {nt}"""',
            f'        node = ParseTreeNode("{nt}")',
            '        la = self.lookahead()',
            '',
        ]
        
        # Group productions by their FIRST set
        first_cases = []
        epsilon_prod = None
        
        for prod in productions:
            first_set = self.analyzer.first_of_production(prod)
            terminals = [t for t in first_set if t != EPSILON]
            
            if prod.is_epsilon_production() or EPSILON in first_set:
                epsilon_prod = prod
                # Also need to handle FOLLOW set
                follow_terminals = list(self.analyzer.follow(nt))
                first_cases.append((follow_terminals, prod, True))
            else:
                first_cases.append((terminals, prod, False))
        
        # Generate if-elif chain
        first = True
        for terminals, prod, is_epsilon in first_cases:
            terminal_strs = [f'"{t}"' for t in terminals]
            condition = f'la in [{", ".join(terminal_strs)}]'
            
            if first:
                lines.append(f'        if {condition}:')
                first = False
            else:
                lines.append(f'        elif {condition}:')
            
            if is_epsilon or prod.is_epsilon_production():
                lines.append(f'            # {prod}')
                lines.append('            pass  # ε production')
            else:
                lines.append(f'            # {prod}')
                for symbol in prod.body:
                    if symbol.is_terminal():
                        lines.append(f'            token = self.match("{symbol}")')
                        lines.append(f'            node.children.append(ParseTreeNode("{symbol}", token=token))')
                    elif symbol.is_non_terminal():
                        child_name = self._safe_name(str(symbol))
                        lines.append(f'            node.children.append(self.parse_{child_name}())')
        
        # Add error case
        all_expected = set()
        for terminals, _, _ in first_cases:
            all_expected.update(str(t) for t in terminals)
        expected_str = " or ".join(sorted(all_expected))
        lines.append('        else:')
        lines.append(f'            self.error("{expected_str}")')
        
        lines.append('        return node')
        
        return lines
    
    def _generate_javascript(self) -> str:
        """Generate JavaScript recursive descent parser"""
        lines = [
            '/**',
            ' * Recursive Descent Parser',
            ' * Generated by Grammar Playground',
            ' */',
            '',
            'class ParseError extends Error {',
            '    constructor(message) {',
            '        super(message);',
            '        this.name = "ParseError";',
            '    }',
            '}',
            '',
            'class Token {',
            '    constructor(type, value, pos = 0) {',
            '        this.type = type;',
            '        this.value = value;',
            '        this.pos = pos;',
            '    }',
            '}',
            '',
            'class ParseTreeNode {',
            '    constructor(symbol, children = [], token = null) {',
            '        this.symbol = symbol;',
            '        this.children = children;',
            '        this.token = token;',
            '    }',
            '    ',
            '    isTerminal() {',
            '        return this.token !== null;',
            '    }',
            '}',
            '',
            'class Parser {',
            '    constructor(tokens) {',
            '        this.tokens = tokens;',
            '        this.pos = 0;',
            '        this.currentToken = tokens.length > 0 ? tokens[0] : null;',
            '    }',
            '    ',
            '    error(expected) {',
            '        if (this.currentToken) {',
            '            throw new ParseError(`Expected ${expected} but got ${this.currentToken.type} at position ${this.currentToken.pos}`);',
            '        }',
            '        throw new ParseError(`Expected ${expected} but reached end of input`);',
            '    }',
            '    ',
            '    advance() {',
            '        const token = this.currentToken;',
            '        this.pos++;',
            '        this.currentToken = this.pos < this.tokens.length ? this.tokens[this.pos] : null;',
            '        return token;',
            '    }',
            '    ',
            '    match(expectedType) {',
            '        if (this.currentToken && this.currentToken.type === expectedType) {',
            '            return this.advance();',
            '        }',
            '        this.error(expectedType);',
            '    }',
            '    ',
            '    lookahead() {',
            '        return this.currentToken ? this.currentToken.type : "$";',
            '    }',
            '    ',
            '    parse() {',
            f'        const tree = this.parse{self._capitalize_name(str(self.grammar.start_symbol))}();',
            '        if (this.currentToken !== null) {',
            '            this.error("end of input");',
            '        }',
            '        return tree;',
            '    }',
            '',
        ]
        
        # Generate parsing methods for each non-terminal
        for nt in sorted(self.grammar.non_terminals, key=lambda x: str(x)):
            lines.extend(self._generate_nt_method_js(nt))
            lines.append('')
        
        lines.append('}')
        lines.append('')
        lines.append('module.exports = { Parser, Token, ParseTreeNode, ParseError };')
        
        return '\n'.join(lines)
    
    def _generate_nt_method_js(self, nt: Symbol) -> List[str]:
        """Generate JavaScript parsing method for a non-terminal"""
        method_name = self._capitalize_name(str(nt))
        productions = self.grammar.get_productions_for(nt)
        
        lines = [
            f'    parse{method_name}() {{',
            f'        // Parse {nt}',
            f'        const node = new ParseTreeNode("{nt}");',
            '        const la = this.lookahead();',
            '',
        ]
        
        first_cases = []
        
        for prod in productions:
            first_set = self.analyzer.first_of_production(prod)
            terminals = [t for t in first_set if t != EPSILON]
            
            if prod.is_epsilon_production() or EPSILON in first_set:
                follow_terminals = list(self.analyzer.follow(nt))
                first_cases.append((follow_terminals, prod, True))
            else:
                first_cases.append((terminals, prod, False))
        
        first = True
        for terminals, prod, is_epsilon in first_cases:
            terminal_strs = [f'"{t}"' for t in terminals]
            condition = f'[{", ".join(terminal_strs)}].includes(la)'
            
            if first:
                lines.append(f'        if ({condition}) {{')
                first = False
            else:
                lines.append(f'        }} else if ({condition}) {{')
            
            if is_epsilon or prod.is_epsilon_production():
                lines.append(f'            // {prod}')
                lines.append('            // ε production')
            else:
                lines.append(f'            // {prod}')
                for symbol in prod.body:
                    if symbol.is_terminal():
                        lines.append(f'            const token = this.match("{symbol}");')
                        lines.append(f'            node.children.push(new ParseTreeNode("{symbol}", [], token));')
                    elif symbol.is_non_terminal():
                        child_name = self._capitalize_name(str(symbol))
                        lines.append(f'            node.children.push(this.parse{child_name}());')
        
        all_expected = set()
        for terminals, _, _ in first_cases:
            all_expected.update(str(t) for t in terminals)
        expected_str = " or ".join(sorted(all_expected))
        
        lines.append('        } else {')
        lines.append(f'            this.error("{expected_str}");')
        lines.append('        }')
        lines.append('        return node;')
        lines.append('    }')
        
        return lines
    
    def _safe_name(self, name: str) -> str:
        """Convert a symbol name to a safe Python identifier"""
        result = name.replace("'", "_prime").replace("-", "_")
        result = ''.join(c if c.isalnum() or c == '_' else '_' for c in result)
        return result.lower()
    
    def _capitalize_name(self, name: str) -> str:
        """Convert a symbol name to CamelCase for JavaScript"""
        safe = self._safe_name(name)
        parts = safe.split('_')
        return ''.join(p.capitalize() for p in parts if p)


class TableDrivenGenerator:
    """Generates a table-driven LL(1) parser"""
    
    def __init__(self, grammar: Grammar, analyzer: LL1Analyzer):
        self.grammar = grammar
        self.analyzer = analyzer
        if not analyzer.ll1_table:
            analyzer.analyze()
    
    def generate(self, language: str = "python") -> str:
        """Generate table-driven parser code"""
        if language.lower() == "python":
            return self._generate_python()
        else:
            raise ValueError(f"Unsupported language: {language}")
    
    def _generate_python(self) -> str:
        """Generate Python table-driven parser"""
        # Build table data
        table_entries = []
        for (nt, terminal), productions in self.analyzer.ll1_table.table.items():
            if productions:
                prod = productions[0]
                body = [str(s) for s in prod.body]
                table_entries.append(f'    ("{nt}", "{terminal}"): {body},')
        
        # Get all terminals and non-terminals
        terminals = sorted([str(t) for t in self.grammar.terminals])
        non_terminals = sorted([str(nt) for nt in self.grammar.non_terminals])
        
        code = f'''"""
Table-Driven LL(1) Parser
Generated by Grammar Playground
"""

from typing import List, Optional, Tuple, Dict


class ParseError(Exception):
    """Raised when parsing fails"""
    pass


class Token:
    """Represents a token from the lexer"""
    def __init__(self, type: str, value: str, pos: int = 0):
        self.type = type
        self.value = value
        self.pos = pos
    
    def __repr__(self):
        return f"Token({{self.type}}, {{self.value!r}})"


class ParseTreeNode:
    """Node in the parse tree"""
    def __init__(self, symbol: str, children: List["ParseTreeNode"] = None, token: Token = None):
        self.symbol = symbol
        self.children = children or []
        self.token = token
    
    def is_terminal(self) -> bool:
        return self.token is not None
    
    def add_child(self, child: "ParseTreeNode"):
        self.children.append(child)


# Grammar information
TERMINALS = {terminals}
NON_TERMINALS = {non_terminals}
START_SYMBOL = "{self.grammar.start_symbol}"

# LL(1) Parsing Table
# Key: (non_terminal, terminal) -> production body as list of symbols
PARSE_TABLE: Dict[Tuple[str, str], List[str]] = {{
{chr(10).join(table_entries)}
}}


class TableDrivenParser:
    """Table-Driven LL(1) Parser"""
    
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.pos = 0
        self.current_token: Optional[Token] = tokens[0] if tokens else None
    
    def lookahead(self) -> str:
        """Return the type of the current token"""
        if self.current_token:
            return self.current_token.type
        return "$"
    
    def advance(self) -> Token:
        """Move to the next token"""
        token = self.current_token
        self.pos += 1
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
        else:
            self.current_token = None
        return token
    
    def parse(self) -> ParseTreeNode:
        """Parse the input using the LL(1) table"""
        # Stack contains (symbol, parent_node) pairs
        root = ParseTreeNode(START_SYMBOL)
        stack: List[Tuple[str, ParseTreeNode]] = [("$", None), (START_SYMBOL, root)]
        
        while stack:
            top_symbol, parent = stack.pop()
            la = self.lookahead()
            
            if top_symbol == "$":
                if la == "$":
                    break
                else:
                    raise ParseError(f"Expected end of input but got {{la}}")
            
            if top_symbol == "ε":
                # Epsilon - do nothing
                continue
            
            if top_symbol in TERMINALS:
                # Terminal - must match
                if top_symbol == la:
                    token = self.advance()
                    if parent:
                        parent.children.append(ParseTreeNode(top_symbol, token=token))
                else:
                    raise ParseError(f"Expected {{top_symbol}} but got {{la}}")
            
            elif top_symbol in NON_TERMINALS:
                # Non-terminal - consult the table
                key = (top_symbol, la)
                if key not in PARSE_TABLE:
                    raise ParseError(f"No production for {{top_symbol}} with lookahead {{la}}")
                
                production_body = PARSE_TABLE[key]
                
                # Create a node for this non-terminal
                node = ParseTreeNode(top_symbol)
                if parent:
                    parent.children.append(node)
                
                # Push production body in reverse order
                for symbol in reversed(production_body):
                    stack.append((symbol, node))
            
            else:
                raise ParseError(f"Unknown symbol: {{top_symbol}}")
        
        return root


def tokenize_simple(text: str) -> List[Token]:
    """Simple tokenizer for testing - splits on whitespace"""
    tokens = []
    pos = 0
    for word in text.split():
        tokens.append(Token(word, word, pos))
        pos += len(word) + 1
    return tokens


if __name__ == "__main__":
    # Example usage
    test_input = "your input here"
    tokens = tokenize_simple(test_input)
    parser = TableDrivenParser(tokens)
    try:
        tree = parser.parse()
        print("Parse successful!")
        print(tree)
    except ParseError as e:
        print(f"Parse error: {{e}}")
'''
        return code
